{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome A trashy blog written by a human. Available Posts Built via mkdocs gh-deploy --site-dir build-output Operating System Database C# and .NET Ext.js Project layout mkdocs.yml # Blog configuration. hands-on/ # Bits of code examples. docs/ index.md # Homepage. hands-on/ # Concepts in practice. quotes-n-trivias/ # Random quotes and trivias.","title":"Home"},{"location":"#welcome","text":"A trashy blog written by a human.","title":"Welcome"},{"location":"#available-posts","text":"Built via mkdocs gh-deploy --site-dir build-output Operating System Database C# and .NET Ext.js","title":"Available Posts"},{"location":"#project-layout","text":"mkdocs.yml # Blog configuration. hands-on/ # Bits of code examples. docs/ index.md # Homepage. hands-on/ # Concepts in practice. quotes-n-trivias/ # Random quotes and trivias.","title":"Project layout"},{"location":"hands-on/core-csharp-n-dotnet/","text":"Boxing v Unboxing, Value v Reference Type Conversion between value type and reference types, boxing bridging them together to provide a uniform type system that were all derived from Object. Sometimes we store value type within reference type variables, we need boxing to put it in, and unboxing it when in need of accessing it. Value of value type copies over value itself on the stack. Whereas reference types were stored on the heap. If we were to use Generics, explicitly declaring the types being stored, we no longer need the boxing/unboxing. Value Types | +--------------+ | | Boxing Unboxing | | \u2b07\ufe0f \u2b06\ufe0f +--------------+ | Reference Types Destructors WIP sample code ~ClassName { clean up } : IDisposable + public void Dispose (== using (..) {} ) try .. catch .. finally .. const v readonly literally constant, limited val types Freer, all kinds of types this v base sample code base calls mother class\u2019 thingy this calls current class\u2019 methods/vars generics v overload generics ensure uniformity overloading get you more than handling different types, but also methods with different length of parameters List ICollection \u27a1\ufe0f IList \u27a1\ufe0f List Each with different set of methods impl_ed Copy v Clone sample code One is shallow, one is (usually) deep One gets a new obj that points to the same memory address of the object you are copying, one gets a completely new object, all built from scratch Customizing your DeepCopy would get you more flexibility than IClonable with Clone Interface v Abstract Class sample code interface defines contracts you need to fullfil, and there might be multiple of them interface has no fields abstract defines a common base class with potentially partial implementation abstract has fields as they are classes ref v out sample code ref variables along with ref would affect the original out pouring out a variable to the function-invocation scope","title":"Core csharp n dotnet"},{"location":"hands-on/core-database/","text":"full context I'm NOT a DB dev I rarely operate on DB directly (I use ORM) I believe if you didn't type the commands on the existing DB, it was all theory I wanted to learn more about DB It was fun renaming a database I guess it wasn't normally done. I purely changed it for the sake of learning. get the new one created before renaming CREATE DATABASE testdb; generate the script based on the existing database SELECT CONCAT( 'RENAME TABLE ','`\u65e7\u5e93`','.`',TABLE_NAME, '` TO ','`testdb`.`',TABLE_NAME,'`;' ) FROM information_schema.TABLES WHERE table_schema LIKE '\u65e7\u5e93'; run the script USE `\u65e7\u5e93`; -- the SQL generated from the previous step table partitioning context I wasn't in a position to do this in production, but I still wanted to learn about it. so I got a local MySQL database in Docker and tried it out. all normal CRUDs would be exactly the same if not considering efficient queries. firstly, it was normally done in the design phase with the table creation so that it knows which table it was operating on. CREATE TABLE Quotes ( row_id INT AUTO_INCREMENT, creator VARCHAR(255), quotes VARCHAR(255), created DATE, PRIMARY KEY (row_id, created) ) PARTITION BY RANGE (YEAR(created)) ( PARTITION p2019 VALUES LESS THAN (2020), PARTITION p2020 VALUES LESS THAN (2021), PARTITION p2021 VALUES LESS THAN (2022), PARTITION p2022 VALUES LESS THAN (2023), PARTITION p2023 VALUES LESS THAN (2024), PARTITION p2024 VALUES LESS THAN (2025) ); secondly making sure it was properly done, logically, in detail SELECT * FROM information_schema.PARTITIONS WHERE TABLE_SCHEMA = 'testdb' AND TABLE_NAME = 'Quotes'; checking how it was done, physically, in the file system If you were like me, using MySQL Docker and be able to access the container # enter the shell docker exec -it mysql sh # testdb is your database name # quotes is your table name ls /var/lib/mysql/testdb | grep -i quotes # you are expected to see something like this # /var/lib/mysql/testdb/ # \u251c\u2500\u2500 Quotes#P#p2019.ibd # \u251c\u2500\u2500 Quotes#P#p2020.ibd # \u251c\u2500\u2500 Quotes#P#p2021.ibd # \u251c\u2500\u2500 Quotes#P#p2022.ibd # \u251c\u2500\u2500 Quotes#P#p2023.ibd # \u2514\u2500\u2500 Quotes#P#p2024.ibd issues I've faced when operating on an existing table with complex relations conclusion: not reading the docs to carefully, should have done it in the design phase Foreign keys are not yet supported in conjunction with partitioning A PRIMARY KEY must include all columns in the table's partitioning function (prefixed columns are not considered). .. get sample data for a table The last line is the one you need to edit to match your table schema USE `testdb`; DELIMITER // CREATE PROCEDURE GenerateSampleData(IN dbName VARCHAR(255), IN tableName VARCHAR(255)) BEGIN DECLARE i INT DEFAULT 0; DECLARE randomName VARCHAR(255); DECLARE randomQuote VARCHAR(255); DECLARE randomDate DATE; DECLARE nameList VARCHAR(255) DEFAULT 'Alice,Bob,Charlie,David,Eve,Frank,Grace,Hank,Ivy,Jack'; DECLARE quoteList VARCHAR(255) DEFAULT 'Sample quote 1.,Sample quote 2.,Sample quote 3.,Sample quote 4.,Sample quote 5.'; WHILE i < 100000 DO SET randomName = ELT(1 + FLOOR(RAND() * 10), 'Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank', 'Grace', 'Hank', 'Ivy', 'Jack'); SET randomQuote = ELT(1 + FLOOR(RAND() * 5), 'Sample quote 1.', 'Sample quote 2.', 'Sample quote 3.', 'Sample quote 4.', 'Sample quote 5.'); SET randomDate = DATE_ADD('2019-01-01', INTERVAL FLOOR(RAND() * 1825) DAY); -- Random date between 2019 and 2024 SET @insertQuery = CONCAT('INSERT INTO ', dbName, '.', tableName, ' (creator, quotes, created) VALUES (''', randomName, ''', ''', randomQuote, ''', ''', randomDate, ''')'); PREPARE stmt FROM @insertQuery; EXECUTE stmt; DEALLOCATE PREPARE stmt; SET i = i + 1; END WHILE; END // DELIMITER ; -- the DB wasn't specfial, just run `CREATE DATABASE testdb;` before this -- the table definition shall be the same as **table partitioning** section CALL GenerateSampleData('testdb', 'Quotes');","title":"Core database"},{"location":"hands-on/core-operatingsystem/","text":"context I used to use full-fledged VMs I wanna try running a full Linux OS in/as a Docker container Real Linux instead of the macOS :< Easier to manage (Docker API) Lighter (I don't need the GUI) setup the base environment choose a distro with proper version I'm most familiar with Ubuntu I gotta choose a LTS version I chose Ubuntu 22.04 LTS (data below is based on this version) Not too new (I got no time to check potential breaking changes on various aspects) End of { standard support: 2027/06, life: 2023/04 } data on the LTS it was based on the first version (cuz there were still Ubuntu 22.04. * ) list of releases on the official website","title":"Core operatingsystem"},{"location":"hands-on/random-extjs-overview/","text":"Metadata Version 4.2 Documentation here Scenarios and Thoughts Create and configure the data source var store = Ext.create( 'Ext.data.Store', { [ 'id', 'name' ], getWhatFromWhereInHow: { \u5f02\u6b65, 'File/Func', { root: 'data' } (\u91ccid/name) }, autoReqAndLoadDataInTheVariable } ) Use existing component var win = Ext.create('userDefinedComponent', { tweaks }) win.loadData(); // <- Ext.apply(this, { k:v, I: impl }) win.show(); // <- extend: 'Ext.window.Window' // 0. It is always listening to various events // 1. You close the component // 2. It calls .close (.window.Window -> .panel.Panel) // 3. It fires up the 'close' event // 4. It runs code you have defined win.on('close', function() { .. }); Toolbars // At the top, commonly for CRUD operations tbar: [ { xtype: 'button', text: 'Button 1' } { customButton } ] var customButton = Ext.create( 'Ext.button.Button', { \u6309\u94ae\u540d // e.g. \u5bfc\u5165 \u6309\u94ae\u56fe\u6807 // e.g. icon-export \u6309\u4e0b\u53bb\u505a\u4ec0\u4e48 // e.g. set var, call func } ) // At the bottom, commonly used for paging bbar: Ext.create( 'Ext.PagingToolbar', { dataSource displayPagingInfo } ) Grand Layout { region: \"center\" // ~= left region: \"east\" region: \"north\" flex: 1 } Components inside components var withShorthand = Ext.create('Ext.Container', { region: 'north', border: false, height: 36, items: [{ xtype: 'form', layout: 'hbox', defaults: { margin: 3 }, items: [ { xtype: 'textfield', fieldLabel: 'Name' }, { xtype: 'button', text: 'Submit' }] }] }); var withoutShorthand = Ext.create('Ext.Container', { region: 'north', border: false, height: 36, items: [ Ext.create('Ext.form.Panel', { layout: Ext.create('Ext.layout.container.HBox'), defaults: { margin: 3 }, items: [ Ext.create('Ext.form.field.Text', { fieldLabel: 'Name' }), Ext.create('Ext.button.Button', { text: 'Submit' }) ] }) ] }); Grid/Table with listener selectionchange // Table -> [[Supercharged]] -> Grid (fetch/sort/filter/..) // Models like Ext.selection.xxModel // classes were imported via 'uses: []' by the Table // events fired by the xxModel will be relayed to the Table // implementation needed to handle the events in the listeners var sampleGrid = Ext.create( 'ZAN.BrandManagement.BrandGrid', { \u540d\u79f0 \u6bd4\u4f8b \u533a\u57df \u5177\u680f listeners: { // selModel Ext.selection.Model .getCount, getStore // records Ext.data.Model [0].get('id') selectionchange: function (selModel, records) { if (!Ext.isEmpty(selectedRecord)) { // Always an array even with one item selectedRecord[0].get('Name'); selectedRecord[0].get('Id'); } } } ); Methods seen from Ext.form.Panel // .up // .down // .setDisabled (universal)","title":"Random extjs overview"},{"location":"hands-on/random-extjs-overview/#metadata","text":"Version 4.2 Documentation here","title":"Metadata"},{"location":"hands-on/random-extjs-overview/#scenarios-and-thoughts","text":"Create and configure the data source var store = Ext.create( 'Ext.data.Store', { [ 'id', 'name' ], getWhatFromWhereInHow: { \u5f02\u6b65, 'File/Func', { root: 'data' } (\u91ccid/name) }, autoReqAndLoadDataInTheVariable } ) Use existing component var win = Ext.create('userDefinedComponent', { tweaks }) win.loadData(); // <- Ext.apply(this, { k:v, I: impl }) win.show(); // <- extend: 'Ext.window.Window' // 0. It is always listening to various events // 1. You close the component // 2. It calls .close (.window.Window -> .panel.Panel) // 3. It fires up the 'close' event // 4. It runs code you have defined win.on('close', function() { .. }); Toolbars // At the top, commonly for CRUD operations tbar: [ { xtype: 'button', text: 'Button 1' } { customButton } ] var customButton = Ext.create( 'Ext.button.Button', { \u6309\u94ae\u540d // e.g. \u5bfc\u5165 \u6309\u94ae\u56fe\u6807 // e.g. icon-export \u6309\u4e0b\u53bb\u505a\u4ec0\u4e48 // e.g. set var, call func } ) // At the bottom, commonly used for paging bbar: Ext.create( 'Ext.PagingToolbar', { dataSource displayPagingInfo } ) Grand Layout { region: \"center\" // ~= left region: \"east\" region: \"north\" flex: 1 } Components inside components var withShorthand = Ext.create('Ext.Container', { region: 'north', border: false, height: 36, items: [{ xtype: 'form', layout: 'hbox', defaults: { margin: 3 }, items: [ { xtype: 'textfield', fieldLabel: 'Name' }, { xtype: 'button', text: 'Submit' }] }] }); var withoutShorthand = Ext.create('Ext.Container', { region: 'north', border: false, height: 36, items: [ Ext.create('Ext.form.Panel', { layout: Ext.create('Ext.layout.container.HBox'), defaults: { margin: 3 }, items: [ Ext.create('Ext.form.field.Text', { fieldLabel: 'Name' }), Ext.create('Ext.button.Button', { text: 'Submit' }) ] }) ] }); Grid/Table with listener selectionchange // Table -> [[Supercharged]] -> Grid (fetch/sort/filter/..) // Models like Ext.selection.xxModel // classes were imported via 'uses: []' by the Table // events fired by the xxModel will be relayed to the Table // implementation needed to handle the events in the listeners var sampleGrid = Ext.create( 'ZAN.BrandManagement.BrandGrid', { \u540d\u79f0 \u6bd4\u4f8b \u533a\u57df \u5177\u680f listeners: { // selModel Ext.selection.Model .getCount, getStore // records Ext.data.Model [0].get('id') selectionchange: function (selModel, records) { if (!Ext.isEmpty(selectedRecord)) { // Always an array even with one item selectedRecord[0].get('Name'); selectedRecord[0].get('Id'); } } } ); Methods seen from Ext.form.Panel // .up // .down // .setDisabled (universal)","title":"Scenarios and Thoughts"}]}